const t = window.App.h;

import "./chunk-deed3e85.js";

import { a as e } from "./chunk-dfef6d51.js";

import { a as s } from "./chunk-868ccbc3.js";

import { a as n, b as o } from "./chunk-515d15f9.js";

import { a } from "./chunk-a343ce23.js";

import { a as i } from "./chunk-adf5a5b1.js";

import { a as r, b as c, c as l, d as h, e as u, f as d, g as p, h as g, i as w, j as f, k as y, l as m, m as b, n as S, o as v, p as k, q as A, r as P, s as T, t as C } from "./chunk-8b806219.js";

import { a as O } from "./chunk-9cf92136.js";

class x {
  constructor() {
    this.history = {}, this.apps = [], this.canUseApps = !1, this.user = {}, this.web3Detected = !1, 
    this.hasDetectedNetwork = !1, this.networkPermitted = !1, this.enoughCounterpartyBalance = !0, 
    this.enoughLocalBalance = !0, this.ethPendingDepositTxHash = "", this.hasLocalStorage = !1, 
    this.hasCorruptStateChannelState = !1, this.runningApps = [];
  }
  appClickedHandler(t) {
    this.history.push(t.detail.dappContainerUrl, t.detail);
  }
  async componentWillLoad() {
    this.runningApps = [ Object.assign({}, this.apps[0], {
      notifications: 11
    }) ];
  }
  checkLocalStorage() {
    if (this.hasLocalStorage) return;
    const e = {
      brave: {
        title: "Please, lower your Shields!",
        instruction: t("span", null, "Please, turn off the ", t("i", null, "Shields Up"), " feature for this site to continue.")
      },
      chrome: {
        title: "Please, allow site data!",
        instruction: t("span", null, "Please, unblock ", t("i", null, "Cookies"), " in your settings, under", " ", t("i", null, "Privacy â†’ Content settings"), ".")
      },
      edge: {
        title: "Please, unblock us!",
        instruction: t("span", null, "Please, uncheck the ", t("i", null, "Block all cookies"), " option in your settings, under ", t("i", null, "Advanced Settings â†’ Cookies"), ".")
      },
      firefox: {
        title: "Please, enable DOM Storage!",
        instruction: t("span", null, "Please, set the ", t("code", null, "dom.storage.enabled"), " key to", " ", t("code", null, "true"), " in your ", t("code", null, "about:config"), " screen.")
      },
      safari: {
        title: "Please, unblock us!",
        instruction: t("span", null, "Please, uncheck the ", t("i", null, "Always block"), " option in your settings, under ", t("i", null, "Preferences â†’ Privacy â†’ Cookies and website data"), ".")
      },
      default: {
        title: "Please, allow us to store data",
        instruction: t("span", null, "The Playground demo uses Local Storage to work properly. Please, configure your browser to grant us access.")
      }
    };
    let s = {};
    return s = navigator.userAgent.indexOf("brave") >= 0 ? e.brave : navigator.userAgent.indexOf("Chrome") >= 0 && navigator.vendor.indexOf("Google") >= 0 ? e.chrome : navigator.userAgent.indexOf("Edge") >= 0 ? e.edge : navigator.userAgent.indexOf("Safari") >= 0 ? e.safari : navigator.userAgent.indexOf("Firefox") >= 0 ? e.firefox : e.default, 
    t("div", {
      class: "error-message"
    }, t("h1", null, s.title), t("h2", null, "The Playground Demo uses Local Storage to work properly.", " ", s.instruction), t("p", null, t("strong", null, "What do we store?"), " Basic information the demo needs to work, such as a mnemonic key to generate the address for your local Node instance, and the data the Node itself stores about the activity in the state channels you are part of."));
  }
  checkDetectedNetwork() {
    if (!this.hasDetectedNetwork) return t("widget-spinner", {
      type: "dots"
    });
  }
  getSuggestedWallet() {
    return screen.width < 600 ? t("span", null, t("a", {
      href: "https://wallet.coinbase.com/"
    }, "Coinbase Wallet"), ",", t("a", {
      href: "https://www.cipherbrowser.com/"
    }, " Cipher"), ", or", t("a", {
      href: "https://dev.status.im/"
    }, " Status")) : t("a", {
      href: "https://metamask.io/"
    }, "Metamask");
  }
  checkWeb3Detected() {
    if (!this.web3Detected) return t("div", {
      class: "error-message"
    }, t("h2", null, "Welcome to the Playground demo :) This demo requires a Web3-compatible wallet such as ", this.getSuggestedWallet(), ". Please enable or download one to continue!"));
  }
  checkNetworkPermitted() {
    if (!this.networkPermitted) return t("div", {
      class: "error-message"
    }, t("h1", null, "Please Switch to Kovan"), t("h2", null, "The Playground demo is currently only deployed on the Kovan test network. Please switch to continue."));
  }
  checkCorruptState() {
    if (this.hasCorruptStateChannelState) return t("div", {
      class: "error-message"
    }, t("h1", null, "â˜ ï¸ Corrupt Wallet State"), t("h2", null, "Unfortunately, your state channel state has become corrupted or lost. Please ", t("a", {
      onClick: this.deleteAccount
    }, "click here"), " to start over."));
  }
  showApps() {
    return t("div", {
      class: "container"
    }, t("apps-list", {
      apps: this.apps,
      onAppClicked: t => this.appClickedHandler(t),
      name: "Available Apps"
    }), this.welcomeText());
  }
  checkUserNotLoggedIn() {
    if (!this.user.id) return this.welcomeText();
  }
  welcomeText() {
    return t("div", {
      class: "welcome-message",
      style: {
        display: this.user.id ? "contents" : "flex"
      }
    }, this.user.id ? void 0 : t("h1", null, "Welcome! ðŸ‘‹"), this.user.id ? void 0 : t("h2", null, "This a demonstration of", " ", t("a", {
      href: "https://counterfactual.com/statechannels"
    }, "generalized state channels"), " ", "on Ethereum."), t("div", {
      class: "flex-container"
    }, t("div", {
      class: "flex-item"
    }, t("h3", null, "What's going on here?"), t("p", null, "You are now a Node in a hub-and-spoke state channels network demo called the Counterfactual Playground, running on Kovan. This webpage is your state channels wallet. Our team runs the hub. Users that connect to our hub can use an unlimited number of off-chain applications with ", t("b", null, "zero fees"), " and", " ", t("b", null, "zero block confirmation times"), ". Want to try? Register or login to start.")), t("div", {
      class: "flex-item"
    }, t("h3", null, "How does it work?"), t("p", null, "This demo is built using", " ", t("a", {
      href: "https://counterfactual.com"
    }, "Counterfactual"), ". We've written all about the internal architecture in", " ", t("a", {
      href: "https://medium.com/statechannels/development-update-3-counterfactual-playground-release-f428be4b8950"
    }, "this blog post"), ". To learn more, check out our", " ", t("a", {
      href: "https://github.com/counterfactual"
    }, "GitHub"), " page and follow us on", " ", t("a", {
      href: "https://twitter.com/statechannels"
    }, "Twitter")))), t("div", {
      class: "flex-container"
    }, t("div", {
      class: "flex-item"
    }, t("h3", null, "What is Counterfactual?"), t("p", null, "Counterfactual is an open-source project comprised of several components:", t("ul", null, t("li", null, "â€¢ A library for off-chain applications"), t("li", null, "â€¢ An intuitive generalized state channels protocol"), t("li", null, "â€¢ A set of Ethereum smart contracts")), " ", "It enables developers to build trustless distributed applications with minimal overhead. Watch", " ", t("a", {
      href: "https://youtu.be/tfKtLNlPL2w?t=72",
      target: "_blank"
    }, "our recent talk"), " ", "at EthCC for more.")), t("div", {
      class: "flex-item"
    }, t("h3", null, "How is this secure?"), t("p", null, "Counterfactual uses state channels, a Layer 2 scalability technique. For a complete overview, read", " ", t("a", {
      href: "https://medium.com/l4-media/making-sense-of-ethereums-layer-2-scaling-solutions-state-channels-plasma-and-truebit-22cb40dcc2f4",
      target: "_blank"
    }, "Making Sense of Layer 2"), " ", "or watch the associated", " ", t("a", {
      href: "https://www.youtube.com/watch?v=RghzB4C9aSg",
      target: "_blank"
    }, "talk from Devcon IV"), "."))));
  }
  checkInsufficientBalance() {
    if (this.user && this.user.multisigAddress) return this.enoughLocalBalance ? this.enoughCounterpartyBalance ? void 0 : t("div", {
      class: "error-message"
    }, t("h1", null, "The Playground Node has insufficient funds"), t("h2", null, "Eventually we'll take care of this automatically, but in the meantime, you'll need to deposit some ETH.", t("br", null), t("br", null), t("stencil-route-link", {
      url: "/exchange"
    }, "Click here"), " ", "to deposit more funds.")) : t("div", {
      class: "error-message"
    }, t("h1", null, "Insufficient funds"), t("h2", null, "Your balance needs to be of at least 0.01 ETH.", t("br", null), t("br", null), t("stencil-route-link", {
      url: "/exchange"
    }, "Click here"), " ", "to deposit more funds."));
  }
  render() {
    const e = this.checkLocalStorage() || this.checkDetectedNetwork() || this.checkWeb3Detected() || this.checkNetworkPermitted() || this.checkUserNotLoggedIn() || this.checkInsufficientBalance() || this.checkCorruptState() || this.showApps();
    return this.hasLocalStorage ? t("node-listener", {
      history: this.history
    }, t("layout-header", null), t("section", {
      class: "section fill"
    }, e), t("a", {
      id: "discordbutton",
      href: "https://discord.gg/7SMbDz",
      target: "_blank"
    })) : t("div", null, t("layout-header", null), t("section", {
      class: "section fill"
    }, e));
  }
  static get is() {
    return "app-home";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      apps: {
        type: "Any",
        attr: "apps"
      },
      canUseApps: {
        type: Boolean,
        attr: "can-use-apps"
      },
      deleteAccount: {
        type: "Any",
        attr: "delete-account"
      },
      element: {
        elementRef: !0
      },
      enoughCounterpartyBalance: {
        type: Boolean,
        attr: "enough-counterparty-balance"
      },
      enoughLocalBalance: {
        type: Boolean,
        attr: "enough-local-balance"
      },
      ethPendingDepositAmountWei: {
        type: "Any",
        attr: "eth-pending-deposit-amount-wei"
      },
      ethPendingDepositTxHash: {
        type: String,
        attr: "eth-pending-deposit-tx-hash"
      },
      hasCorruptStateChannelState: {
        type: Boolean,
        attr: "has-corrupt-state-channel-state"
      },
      hasDetectedNetwork: {
        type: Boolean,
        attr: "has-detected-network"
      },
      hasLocalStorage: {
        type: Boolean,
        attr: "has-local-storage"
      },
      history: {
        type: "Any",
        attr: "history"
      },
      networkPermitted: {
        type: Boolean,
        attr: "network-permitted"
      },
      runningApps: {
        state: !0
      },
      user: {
        type: "Any",
        attr: "user"
      },
      web3Detected: {
        type: Boolean,
        attr: "web-3-detected"
      }
    };
  }
  static get style() {
    return "/**style-placeholder:app-home:**/";
  }
}

s.injectProps(x, [ "apps", "canUseApps" ]), a.injectProps(x, [ "web3Detected", "networkPermitted", "hasDetectedNetwork" ]), 
e.injectProps(x, [ "user", "hasCorruptStateChannelState", "enoughCounterpartyBalance", "enoughLocalBalance", "ethPendingDepositAmountWei", "ethPendingDepositTxHash", "deleteAccount" ]);

class L {
  static create(t) {
    if (L.app) return L.app;
    L.app = window.firebase.initializeApp(t);
  }
  static createMessagingService(t) {
    return new E(L.app.database(), t);
  }
  static createStoreService(t) {
    return new B(L.app.database(), t);
  }
}

class E {
  constructor(t, e) {
    this.firebase = t, this.messagingServerKey = e;
  }
  async send(t, e) {
    await this.firebase.ref(`${this.messagingServerKey}/${t}/${e.from}`).set(JSON.parse(JSON.stringify(e)));
  }
  onReceive(t, e) {
    this.firebase.app ? (this.firebase.ref(`${this.messagingServerKey}/${t}`).remove(), 
    this.firebase.ref(`${this.messagingServerKey}/${t}`).on("child_added", async s => {
      if (!s) return void console.error(`Node with address ${t} received a "null" snapshot`);
      const n = s.val();
      if (null !== n) {
        n.from !== s.key && console.error("Incorrect message received", n), await this.firebase.ref(`${this.messagingServerKey}/${t}/${n.from}`).remove();
        try {
          console.log("Received message from", t, n, "Handling via", e), e(n);
        } catch (t) {
          console.error("Encountered an error while handling message callback", t);
        }
      }
    })) : console.error("Cannot register a connection with an uninitialized firebase handle");
  }
}

class B {
  constructor(t, e) {
    this.firebase = t, this.storeServiceKey = e;
  }
  async get(t) {
    let e;
    return await this.firebase.ref(this.storeServiceKey).child(t).once("value", s => {
      null !== s ? e = s.val() : console.debug(`Failed to retrieve value at ${t}: received a "null" snapshot`);
    }), e;
  }
  async set(t) {
    const e = {};
    for (const s of t) e[s.key] = JSON.parse(JSON.stringify(s.value));
    await this.firebase.ref(this.storeServiceKey).update(e);
  }
}

const W = "production", U = "", R = "", D = "", N = "", j = "", I = "", M = {
  42: "kovan"
}, H = 3e4;

class F {
  constructor() {
    this.loading = !0, this.accountState = {
      enoughCounterpartyBalance: !0,
      enoughLocalBalance: !0
    }, this.walletState = {}, this.appRegistryState = {
      apps: [],
      canUseApps: !1,
      schemaVersion: "",
      maintenanceMode: !1
    }, this.hasLocalStorage = !1, this.modal = t("div", null), this.redirect = t("div", null);
  }
  componentWillLoad() {
    try {
      localStorage.setItem("playground:localStorage", "true"), localStorage.removeItem("playground:localStorage"), 
      this.hasLocalStorage = !0;
    } catch (t) {
      this.hasLocalStorage = !1;
    }
    this.setup();
  }
  async updateAccount(t) {
    this.accountState = Object.assign({}, this.accountState, t), this.bindProviderEvents(), 
    this.setSentryUser(this.accountState);
  }
  setSentryUser(t) {
    window.Sentry.configureScope(e => {
      e.setUser({
        email: t.user.email,
        username: t.user.username,
        id: t.user.id
      }), e.setExtra("ethAddress", t.user.ethAddress), e.setExtra("multisigAddress", t.user.multisigAddress), 
      e.setExtra("nodeAddress", t.user.nodeAddress);
    });
  }
  async updateWalletConnection(t) {
    this.walletState = Object.assign({}, this.walletState, t);
  }
  async updateAppRegistry(t) {
    this.appRegistryState = Object.assign({}, this.appRegistryState, t);
  }
  async updateMultisigBalance(t) {
    t.eq(window.ethers.constants.Zero) && this.accountState.ethPendingDepositAmountWei || this.updateAccount({
      ethMultisigBalance: t,
      ethPendingDepositAmountWei: void 0
    });
  }
  async updateWalletBalance(t) {
    await this.updateWalletConnection({
      ethWeb3WalletBalance: t
    });
  }
  async setup() {
    this.loadEnv(), this.loadSentry(), void 0 !== window.web3 && await Promise.all([ this.heartbeat(), this.createNodeProvider(), this.loadApps() ]), 
    this.loading = !1;
  }
  async redirectToDeposit() {
    this.modal = {}, this.redirect = t("stencil-router-redirect", {
      url: "/deposit"
    });
  }
  async createNodeProvider() {
    if (!this.hasLocalStorage) return;
    let t;
    L.create(t = {
      apiKey: U,
      authDomain: R,
      databaseURL: D,
      projectId: j,
      storageBucket: I,
      messagingSenderId: N
    });
    const e = L.createMessagingService("messaging"), s = {
      async get(t) {
        const e = {}, s = Object.keys(window.localStorage);
        for (const n of s) if (n.includes(t)) {
          const s = JSON.parse(window.localStorage.getItem(n));
          if (n === t) return s;
          e[n] = s;
        }
        for (const t of Object.keys(e)) {
          const s = t.split("/")[t.split("/").length - 1], n = e[t];
          delete e[t], e[s] = n;
        }
        return Object.keys(e).length > 0 ? e : void 0;
      },
      async set(t) {
        t.forEach(({key: t, value: e}) => {
          window.localStorage.setItem(t, JSON.stringify(e));
        });
      }
    };
    await n.create({
      messagingService: e,
      storeService: s,
      nodeConfig: {
        STORE_KEY_PREFIX: "store"
      },
      network: "kovan"
    });
  }
  loadEnv() {
    window.globalConfig = {
      TIER: W
    };
  }
  loadSentry() {
    window.Sentry.init({
      dsn: "https://6037586d37124e518f4718d9dd46b18b@sentry.io/1383439",
      release: `playground@${Date.now()}`,
      environment: W
    });
  }
  async loadApps() {
    const t = await i.getApps();
    await this.updateAppRegistry({
      apps: t
    });
  }
  async heartbeat() {
    setInterval(async () => this.doHeartbeat(), H), this.doHeartbeat();
  }
  async doHeartbeat() {
    const t = await i.getHeartbeat();
    this.updateAppRegistry(Object.assign({}, t));
  }
  bindProviderEvents() {
    const {user: {multisigAddress: t, ethAddress: e}} = this.accountState, {provider: s} = this.walletState;
    s && t && e && (e && (s.removeAllListeners(e), s.on(e, this.updateWalletBalance.bind(this))), 
    t && (s.removeAllListeners(t), s.on(t, this.updateMultisigBalance.bind(this))));
  }
  buildSignatureMessageForLogin(t) {
    return [ "PLAYGROUND ACCOUNT LOGIN", `Ethereum address: ${t}` ].join("\n");
  }
  async login() {
    const {user: t} = this.accountState, e = this.walletState.signer, s = await e.signMessage(this.buildSignatureMessageForLogin(t.ethAddress)), n = await i.login({
      ethAddress: t.ethAddress
    }, s);
    return window.localStorage.setItem("playground:user:token", n.token), await this.updateAccount({
      user: n
    }), await this.getBalances(), n;
  }
  async deleteAccount() {
    const t = window.localStorage.getItem("playground:user:token");
    if (!t) return void console.error("Couldn't delete account; no token was provided");
    const e = await i.getUser(t);
    try {
      await i.deleteAccount(e), this.updateAccount({
        hasCorruptStateChannelState: !1
      });
    } finally {
      return void this.logout();
    }
  }
  async getBalances({poll: t = !1} = {}) {
    const e = window.ethers.utils.parseEther("0.01"), {user: {multisigAddress: s, ethAddress: o, nodeAddress: a}} = this.accountState, {provider: i} = this.walletState, r = n.getCfProvider();
    if (!s || !o) return {
      ethFreeBalanceWei: window.ethers.constants.Zero,
      ethMultisigBalance: window.ethers.constants.Zero
    };
    let c;
    try {
      c = await r.getFreeBalanceState(s);
    } catch (t) {
      if (t.toString().includes("Call to getFreeBalanceState failed")) return await this.updateAccount({
        hasCorruptStateChannelState: !0
      }), {
        ethFreeBalanceWei: window.ethers.constants.Zero,
        ethMultisigBalance: window.ethers.constants.Zero
      };
      throw t;
    }
    const l = ((t, e) => window.ethers.utils.computeAddress(window.ethers.utils.HDNode.fromExtendedKey(t).derivePath(String(0)).publicKey))(a), [h] = Object.keys(c).filter(t => t !== l), u = c[l], d = c[h], p = {
      ethFreeBalanceWei: u,
      ethMultisigBalance: await i.getBalance(s),
      ethCounterpartyFreeBalanceWei: d
    }, g = d.gte(e), w = u.gte(e), f = g && w;
    return await this.updateAppRegistry({
      canUseApps: f
    }), await this.updateAccount(Object.assign({}, p, {
      enoughCounterpartyBalance: g,
      enoughLocalBalance: w
    })), t && (f ? clearTimeout(this.balancePolling) : this.balancePolling = setTimeout(async () => this.getBalances({
      poll: t
    }), 1e3)), p;
  }
  async resetPendingDepositState() {
    await this.updateAccount({
      ethPendingDepositAmountWei: void 0,
      ethPendingDepositTxHash: void 0
    });
  }
  async resetPendingWithdrawalState() {
    await this.updateAccount({
      ethPendingWithdrawalAmountWei: void 0,
      ethPendingWithdrawalTxHash: void 0
    });
  }
  async deposit(t) {
    const e = localStorage.getItem("playground:user:token"), {multisigAddress: s} = await i.getUser(e), a = n.getCfProvider();
    let r;
    a.once(o.EventName.DEPOSIT_STARTED, async e => {
      console.log("Playground#deposit: DEPOSIT_STARTED"), await this.updateAccount({
        ethPendingDepositTxHash: e.txHash,
        ethPendingDepositAmountWei: t
      });
    }), a.once(o.EventName.DEPOSIT_CONFIRMED, async t => {
      await this.getBalances(), await this.resetPendingDepositState();
    });
    try {
      const e = window.ethers.utils.bigNumberify(t);
      r = await a.deposit(s, e);
    } catch (t) {
      console.error(t);
    }
    return r;
  }
  async withdraw(t) {
    const {user: {multisigAddress: e}} = this.accountState, s = n.getCfProvider();
    let a;
    s.once(o.EventName.WITHDRAWAL_STARTED, e => {
      this.updateAccount({
        ethPendingWithdrawalTxHash: e.txHash,
        ethPendingWithdrawalAmountWei: t
      });
    });
    try {
      const n = window.ethers.utils.bigNumberify(t);
      a = await s.withdraw(e, n, this.accountState.user.ethAddress);
    } catch (t) {
      console.error(t);
    }
    return await this.getBalances(), await this.resetPendingWithdrawalState(), a;
  }
  waitForMultisig() {
    n.getCfProvider().once(o.EventName.CREATE_CHANNEL, this.setMultisigAddress.bind(this));
  }
  async setMultisigAddress(t) {
    const {user: e} = this.accountState;
    e.multisigAddress = t.data.multisigAddress, await this.updateAccount({
      user: e
    });
  }
  async autoLogin() {
    const t = window.localStorage.getItem("playground:user:token");
    if (!t) return;
    const {user: e} = this.accountState;
    if (!e || !e.username) try {
      const e = await i.getUser(t);
      this.updateAccount({
        user: e
      });
    } catch (t) {
      return void this.logout();
    }
    this.accountState.user.multisigAddress ? await this.getBalances() : this.waitForMultisig();
  }
  logout() {
    window.localStorage.removeItem("playground:user:token"), this.updateAccount({
      user: {}
    });
  }
  getEtherscanAddressURL(t) {
    return `https://${M[this.walletState.network]}.etherscan.io/address/${t}`;
  }
  getEtherscanTxURL(t) {
    return `https://${M[this.walletState.network]}.etherscan.io/tx/${t}`;
  }
  upgrade() {
    const t = [ "MNEMONIC", "playground:matchmakeWith" ], e = t.map(t => ({
      [t]: localStorage.getItem(t)
    })).reduce((t, e) => Object.assign({}, t, e), {});
    window.localStorage.clear(), t.forEach(t => {
      window.localStorage.setItem(t, e[t]);
    }), window.localStorage.setItem("playground:schemaVersion", this.appRegistryState.schemaVersion), 
    window.location.reload();
  }
  render() {
    if (this.accountState = Object.assign({}, this.accountState, {
      updateAccount: this.updateAccount.bind(this),
      waitForMultisig: this.waitForMultisig.bind(this),
      login: this.login.bind(this),
      logout: this.logout.bind(this),
      deleteAccount: this.deleteAccount.bind(this),
      getBalances: this.getBalances.bind(this),
      autoLogin: this.autoLogin.bind(this),
      deposit: this.deposit.bind(this),
      withdraw: this.withdraw.bind(this)
    }), this.walletState.updateWalletConnection = this.updateWalletConnection.bind(this), 
    this.walletState.getEtherscanAddressURL = this.getEtherscanAddressURL.bind(this), 
    this.walletState.getEtherscanTxURL = this.getEtherscanTxURL.bind(this), this.appRegistryState.updateAppRegistry = this.updateAppRegistry.bind(this), 
    this.appRegistryState.maintenanceMode) return t("widget-dialog", {
      visible: !0,
      dialogTitle: "Under maintenance",
      content: t("p", null, "Sorry! We're currently working on a few things behind the scenes to keep the demo functional. Please come back later. In the meantime, follow us on Twitter", t("a", {
        href: "https://twitter.com/statechannels",
        target: "_blank"
      }, " ", "@statechannels", " "), "to learn more and keep up to date on the project.")
    });
    if (this.loading) return t("widget-spinner", {
      type: "dots"
    });
    const n = window.localStorage.getItem("playground:schemaVersion");
    return n && n !== this.appRegistryState.schemaVersion ? t("widget-dialog", {
      visible: !0,
      dialogTitle: "A new version of the Playground is available!",
      content: "Click OK to update your experience.",
      primaryButtonText: "OK",
      onPrimaryButtonClicked: this.upgrade.bind(this)
    }) : t(a.Provider, {
      state: this.walletState
    }, t(e.Provider, {
      state: this.accountState
    }, t(s.Provider, {
      state: this.appRegistryState
    }, t("div", {
      class: "app-root wrapper"
    }, t("main", {
      class: "wrapper__content"
    }, this.hasLocalStorage ? t("stencil-router", null, t("stencil-route-switch", {
      scrollTopOffset: 0
    }, t("stencil-route", {
      url: "/",
      component: "app-home",
      exact: !0,
      componentProps: {
        hasLocalStorage: this.hasLocalStorage
      }
    }), t("stencil-route", {
      url: "/dapp/:dappName",
      component: "dapp-container"
    }), t("stencil-route", {
      url: "/account",
      component: "account-edit"
    }), t("stencil-route", {
      url: "/exchange",
      component: "account-exchange"
    }), t("stencil-route", {
      url: "/register",
      component: "account-register"
    }), t("stencil-route", {
      url: "/deposit",
      component: "account-deposit"
    }))) : t("app-home", {
      hasLocalStorage: this.hasLocalStorage
    })), t("webthree-connector", {
      accountState: this.accountState,
      walletState: this.walletState
    }), this.modal || {}, this.redirect || {}))));
  }
  static get is() {
    return "app-root";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      accountState: {
        state: !0
      },
      appRegistryState: {
        state: !0
      },
      balancePolling: {
        state: !0
      },
      hasLocalStorage: {
        state: !0
      },
      loading: {
        state: !0
      },
      modal: {
        state: !0
      },
      redirect: {
        state: !0
      },
      walletState: {
        state: !0
      }
    };
  }
  static get style() {
    return "/**style-placeholder:app-root:**/";
  }
}

const V = [ "42" ];

class K {
  constructor() {
    this.accountState = {}, this.walletState = {};
  }
  getProvider() {
    return new window.ethers.providers.Web3Provider(window.web3.currentProvider);
  }
  getCurrentAddress() {
    return window.web3.eth.accounts[0];
  }
  getCurrentNetwork() {
    return window.web3.version.network;
  }
  async getETHBalance() {
    const t = this.getProvider();
    return t && this.isUnlocked() ? await t.getSigner().getBalance() : window.ethers.constants.Zero;
  }
  isWeb3Detected() {
    return void 0 !== window.web3;
  }
  isMetamask() {
    return window.web3.isMetamask || window.web3.currentProvider.isMetamask;
  }
  isUnlocked() {
    return void 0 !== window.web3.eth.accounts[0];
  }
  isOnPermittedNetwork() {
    return V.includes(this.getCurrentNetwork());
  }
  async getCurrentWalletState() {
    const t = {
      network: "",
      connected: !1,
      metamaskUnlocked: !1,
      web3Detected: this.walletState.web3Detected,
      web3Enabled: this.walletState.web3Enabled,
      networkPermitted: !1,
      hasDetectedNetwork: !0
    };
    return t.metamaskUnlocked = this.isUnlocked(), t.networkPermitted = this.isOnPermittedNetwork(), 
    t.network = this.getCurrentNetwork(), t;
  }
  async componentDidLoad() {
    if (!this.isWeb3Detected()) return this.walletState.updateWalletConnection({
      web3Detected: !1,
      hasDetectedNetwork: !0
    });
    this.accountState.updateAccount({
      user: Object.assign({}, this.accountState.user, {
        ethAddress: this.getCurrentAddress()
      })
    }), this.walletState.updateWalletConnection(Object.assign({}, await this.getCurrentWalletState(), {
      provider: this.getProvider(),
      signer: this.getProvider().getSigner(),
      web3Enabled: !0,
      web3Detected: !0
    }));
    const t = window.setInterval(async () => {
      let e = this.accountState.user.ethAddress;
      const s = this.getCurrentAddress();
      await this.accountState.updateAccount({
        user: Object.assign({}, this.accountState.user, {
          ethAddress: s
        })
      }), await this.walletState.updateWalletConnection({
        ethWeb3WalletBalance: await this.getETHBalance()
      }), s !== e && (this.walletState.updateWalletConnection(await this.getCurrentWalletState()), 
      void 0 !== (e = s) && void 0 === s && clearInterval(t));
    }, 1e3);
  }
  static get is() {
    return "webthree-connector";
  }
  static get encapsulation() {
    return "shadow";
  }
  static get properties() {
    return {
      accountState: {
        type: "Any",
        attr: "account-state"
      },
      walletState: {
        type: "Any",
        attr: "wallet-state"
      }
    };
  }
}

var $ = function(t, e, s, n) {
  return new (s || (s = Promise))(function(o, a) {
    function fulfilled(t) {
      try {
        step(n.next(t));
      } catch (t) {
        a(t);
      }
    }
    function rejected(t) {
      try {
        step(n.throw(t));
      } catch (t) {
        a(t);
      }
    }
    function step(t) {
      t.done ? o(t.value) : new s(function(e) {
        e(t.value);
      }).then(fulfilled, rejected);
    }
    step((n = n.apply(t, e || [])).next());
  });
};

class _ {
  constructor() {
    this.group = null, this.match = null, this.componentProps = {}, this.exact = !1, 
    this.scrollOnNextRender = !1, this.previousMatch = null;
  }
  computeMatch(t) {
    const e = null != this.group || null != this.el.parentElement && "stencil-route-switch" === this.el.parentElement.tagName.toLowerCase();
    if (t && !e) return this.previousMatch = this.match, this.match = r(t.pathname, {
      path: this.url,
      exact: this.exact,
      strict: !0
    });
  }
  loadCompleted() {
    return $(this, void 0, void 0, function*() {
      let t = {};
      this.history && this.history.location.hash ? t = {
        scrollToId: this.history.location.hash.substr(1)
      } : this.scrollTopOffset && (t = {
        scrollTopOffset: this.scrollTopOffset
      }), "function" == typeof this.componentUpdated ? this.componentUpdated(t) : this.match && !c(this.match, this.previousMatch) && this.routeViewsUpdated && this.routeViewsUpdated(t);
    });
  }
  componentDidUpdate() {
    return $(this, void 0, void 0, function*() {
      yield this.loadCompleted();
    });
  }
  componentDidLoad() {
    return $(this, void 0, void 0, function*() {
      yield this.loadCompleted();
    });
  }
  render() {
    if (!this.match || !this.history) return null;
    const e = Object.assign({}, this.componentProps, {
      history: this.history,
      match: this.match
    });
    return this.routeRender ? this.routeRender(Object.assign({}, e, {
      component: this.component
    })) : this.component ? t(this.component, Object.assign({}, e)) : void 0;
  }
  static get is() {
    return "stencil-route";
  }
  static get properties() {
    return {
      component: {
        type: String,
        attr: "component"
      },
      componentProps: {
        type: "Any",
        attr: "component-props"
      },
      componentUpdated: {
        type: "Any",
        attr: "component-updated"
      },
      el: {
        elementRef: !0
      },
      exact: {
        type: Boolean,
        attr: "exact"
      },
      group: {
        type: String,
        attr: "group",
        reflectToAttr: !0
      },
      history: {
        type: "Any",
        attr: "history"
      },
      historyType: {
        type: String,
        attr: "history-type"
      },
      location: {
        type: "Any",
        attr: "location",
        watchCallbacks: [ "computeMatch" ]
      },
      match: {
        type: "Any",
        attr: "match",
        mutable: !0
      },
      routeRender: {
        type: "Any",
        attr: "route-render"
      },
      routeViewsUpdated: {
        type: "Any",
        attr: "route-views-updated"
      },
      scrollTopOffset: {
        type: Number,
        attr: "scroll-top-offset"
      },
      url: {
        type: String,
        attr: "url"
      }
    };
  }
  static get style() {
    return "/**style-placeholder:stencil-route:**/";
  }
}

O.injectProps(_, [ "location", "history", "historyType", "routeViewsUpdated" ]);

var q = function(t, e, s, n) {
  return new (s || (s = Promise))(function(o, a) {
    function fulfilled(t) {
      try {
        step(n.next(t));
      } catch (t) {
        a(t);
      }
    }
    function rejected(t) {
      try {
        step(n.throw(t));
      } catch (t) {
        a(t);
      }
    }
    function step(t) {
      t.done ? o(t.value) : new s(function(e) {
        e(t.value);
      }).then(fulfilled, rejected);
    }
    step((n = n.apply(t, e || [])).next());
  });
};

function isHTMLStencilRouteElement(t) {
  return "stencil-route" === t.tagName.toLowerCase();
}

class Y {
  constructor() {
    this.group = window.crypto ? ([ 1e7 ].toString() + -1e3.toString() + -4e3.toString() + -8e3.toString() + -1e11.toString()).replace(/[018]/g, function(t) {
      return (t ^ window.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> t / 4).toString(16);
    }) : ((1e17 * Math.random()).toString().match(/.{4}/g) || []).join("-"), this.subscribers = [];
  }
  componentWillLoad() {
    null != this.location && this.regenerateSubscribers(this.location);
  }
  regenerateSubscribers(t) {
    return q(this, void 0, void 0, function*() {
      if (null == t) return;
      let e = -1;
      if (this.subscribers = Array.prototype.slice.call(this.el.children).filter(isHTMLStencilRouteElement).map((s, n) => {
        const o = function(e, n, o) {
          return r(t.pathname, {
            path: s.url,
            exact: s.exact,
            strict: !0
          });
        }();
        return o && -1 === e && (e = n), {
          el: s,
          match: o
        };
      }), -1 === e) return;
      if (this.activeIndex === e) return void (this.subscribers[e].el.match = this.subscribers[e].match);
      this.activeIndex = e;
      const s = this.subscribers[this.activeIndex];
      this.scrollTopOffset && (s.el.scrollTopOffset = this.scrollTopOffset), s.el.group = this.group, 
      s.el.match = s.match, s.el.componentUpdated = (t => {
        this.queue.write(() => {
          this.subscribers.forEach((t, e) => {
            if (t.el.componentUpdated = void 0, e === this.activeIndex) return t.el.style.display = "";
            this.scrollTopOffset && (t.el.scrollTopOffset = this.scrollTopOffset), t.el.group = this.group, 
            t.el.match = null, t.el.style.display = "none";
          });
        }), this.routeViewsUpdated && this.routeViewsUpdated(Object.assign({
          scrollTopOffset: this.scrollTopOffset
        }, t));
      });
    });
  }
  render() {
    return t("slot", null);
  }
  static get is() {
    return "stencil-route-switch";
  }
  static get properties() {
    return {
      el: {
        elementRef: !0
      },
      group: {
        type: String,
        attr: "group",
        reflectToAttr: !0
      },
      location: {
        type: "Any",
        attr: "location",
        watchCallbacks: [ "regenerateSubscribers" ]
      },
      queue: {
        context: "queue"
      },
      routeViewsUpdated: {
        type: "Any",
        attr: "route-views-updated"
      },
      scrollTopOffset: {
        type: Number,
        attr: "scroll-top-offset"
      }
    };
  }
}

function invariant(t, ...e) {
  t || console.error(...e);
}

function warning(t, ...e) {
  t || console.warn(...e);
}

O.injectProps(Y, [ "location", "routeViewsUpdated" ]);

const z = () => {
  let t, e = [];
  return {
    setPrompt: e => (warning(null == t, "A history supports only one prompt at a time"), 
    t = e, () => {
      t === e && (t = null);
    }),
    confirmTransitionTo: (e, s, n, o) => {
      if (null != t) {
        const a = "function" == typeof t ? t(e, s) : t;
        "string" == typeof a ? "function" == typeof n ? n(a, o) : (warning(!1, "A history needs a getUserConfirmation function in order to use a prompt message"), 
        o(!0)) : o(!1 !== a);
      } else o(!0);
    },
    appendListener: t => {
      let s = !0;
      const n = (...e) => {
        s && t(...e);
      };
      return e.push(n), () => {
        s = !1, e = e.filter(t => t !== n);
      };
    },
    notifyListeners: (...t) => {
      e.forEach(e => e(...t));
    }
  };
}, J = (t = "scrollPositions") => {
  let e = new Map();
  if (l("sessionStorage")) {
    const s = window.sessionStorage.getItem(t);
    e = s ? new Map(JSON.parse(s)) : e;
  }
  function set(t, s) {
    if (e.set(t, s), l("sessionStorage")) {
      const t = [];
      e.forEach((e, s) => {
        t.push([ s, e ]);
      }), window.sessionStorage.setItem("scrollPositions", JSON.stringify(t));
    }
  }
  return "scrollRestoration" in history && (history.scrollRestoration = "manual"), 
  {
    set,
    get: function(t) {
      return e.get(t);
    },
    has: function(t) {
      return e.has(t);
    },
    capture: function(t) {
      set(t, [ window.scrollX, window.scrollY ]);
    }
  };
}, Z = () => {
  try {
    return window.history.state || {};
  } catch (t) {
    return {};
  }
}, G = {
  hashbang: {
    encodePath: t => "!" === t.charAt(0) ? t : "!/" + T(t),
    decodePath: t => "!" === t.charAt(0) ? t.substr(1) : t
  },
  noslash: {
    encodePath: T,
    decodePath: w
  },
  slash: {
    encodePath: w,
    decodePath: w
  }
}, X = () => {
  const t = window.location.href, e = t.indexOf("#");
  return -1 === e ? "" : t.substring(e + 1);
}, Q = t => {
  const e = window.location.href.indexOf("#");
  window.location.replace(window.location.href.slice(0, e >= 0 ? e : 0) + "#" + t);
};

var tt = function(t, e, s, n) {
  return new (s || (s = Promise))(function(o, a) {
    function fulfilled(t) {
      try {
        step(n.next(t));
      } catch (t) {
        a(t);
      }
    }
    function rejected(t) {
      try {
        step(n.throw(t));
      } catch (t) {
        a(t);
      }
    }
    function step(t) {
      t.done ? o(t.value) : new s(function(e) {
        e(t.value);
      }).then(fulfilled, rejected);
    }
    step((n = n.apply(t, e || [])).next());
  });
};

function getLocation(t, e) {
  const s = 0 == t.pathname.indexOf(e) ? "/" + t.pathname.slice(e.length) : t.pathname;
  return Object.assign({}, t, {
    pathname: s
  });
}

const et = {
  browser: (t = {}) => {
    invariant(h, "Browser history needs a DOM");
    const e = window.history, s = u(), n = !d(), o = J(), a = null != t.forceRefresh && t.forceRefresh, i = null != t.getUserConfirmation ? t.getUserConfirmation : p, r = null != t.keyLength ? t.keyLength : 6, c = t.basename ? g(w(t.basename)) : "", l = t => {
      t = t || {};
      const {key: e, state: s} = t, {pathname: n, search: o, hash: a} = window.location;
      let i = n + o + a;
      return warning(!c || f(i, c), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + i + '" to begin with "' + c + '".'), 
      c && (i = y(i, c)), m(i, s, e || b(r));
    }, P = z(), T = t => {
      o.capture(I.location.key), Object.assign(I, t), I.location.scrollPosition = o.get(I.location.key), 
      I.length = e.length, P.notifyListeners(I.location, I.action);
    }, C = t => {
      A(t) || L(l(t.state));
    }, O = () => {
      L(l(Z()));
    };
    let x = !1;
    const L = t => {
      if (x) x = !1, T(); else {
        const e = "POP";
        P.confirmTransitionTo(t, e, i, s => {
          s ? T({
            action: e,
            location: t
          }) : E(t);
        });
      }
    }, E = t => {
      let e = W.indexOf(I.location.key);
      -1 === e && (e = 0);
      let s = W.indexOf(t.key);
      -1 === s && (s = 0);
      const n = e - s;
      n && (x = !0, R(n));
    }, B = l(Z());
    let W = [ B.key ];
    const U = t => c + S(t), R = t => {
      e.go(t);
    };
    let D = 0;
    const N = t => {
      1 === (D += t) ? (v(window, "popstate", C), n && v(window, "hashchange", O)) : 0 === D && (k(window, "popstate", C), 
      n && k(window, "hashchange", O));
    };
    let j = !1;
    const I = {
      length: e.length,
      action: "POP",
      location: B,
      createHref: U,
      push: (t, n) => {
        warning(!("object" == typeof t && void 0 !== t.state && void 0 !== n), "You should avoid providing a 2nd state argument to push when the 1st argument is a location-like object that already has state; it is ignored");
        const o = m(t, n, b(r), I.location);
        P.confirmTransitionTo(o, "PUSH", i, t => {
          if (!t) return;
          const n = U(o), {key: i, state: r} = o;
          if (s) if (e.pushState({
            key: i,
            state: r
          }, void 0, n), a) window.location.href = n; else {
            const t = W.indexOf(I.location.key), e = W.slice(0, -1 === t ? 0 : t + 1);
            e.push(o.key), W = e, T({
              action: "PUSH",
              location: o
            });
          } else warning(void 0 === r, "Browser history cannot push state in browsers that do not support HTML5 history"), 
          window.location.href = n;
        });
      },
      replace: (t, n) => {
        warning(!("object" == typeof t && void 0 !== t.state && void 0 !== n), "You should avoid providing a 2nd state argument to replace when the 1st argument is a location-like object that already has state; it is ignored");
        const o = m(t, n, b(r), I.location);
        P.confirmTransitionTo(o, "REPLACE", i, t => {
          if (!t) return;
          const n = U(o), {key: i, state: r} = o;
          if (s) if (e.replaceState({
            key: i,
            state: r
          }, void 0, n), a) window.location.replace(n); else {
            const t = W.indexOf(I.location.key);
            -1 !== t && (W[t] = o.key), T({
              action: "REPLACE",
              location: o
            });
          } else warning(void 0 === r, "Browser history cannot replace state in browsers that do not support HTML5 history"), 
          window.location.replace(n);
        });
      },
      go: R,
      goBack: () => R(-1),
      goForward: () => R(1),
      block: (t = "") => {
        const e = P.setPrompt(t);
        return j || (N(1), j = !0), () => (j && (j = !1, N(-1)), e());
      },
      listen: t => {
        const e = P.appendListener(t);
        return N(1), () => {
          N(-1), e();
        };
      }
    };
    return I;
  },
  hash: (t = {}) => {
    invariant(h, "Hash history needs a DOM");
    const e = window.history, s = P(), n = null != t.keyLength ? t.keyLength : 6, {getUserConfirmation: o = p, hashType: a = "slash"} = t, i = t.basename ? g(w(t.basename)) : "", {encodePath: r, decodePath: c} = G[a], l = () => {
      let t = c(X());
      return warning(!i || f(t, i), 'You are attempting to use a basename on a page whose URL path does not begin with the basename. Expected path "' + t + '" to begin with "' + i + '".'), 
      i && (t = y(t, i)), m(t, void 0, b(n));
    }, u = z(), d = t => {
      Object.assign(I, t), I.length = e.length, u.notifyListeners(I.location, I.action);
    };
    let A = !1, T = null;
    const O = () => {
      const t = X(), e = r(t);
      if (t !== e) Q(e); else {
        const t = l(), e = I.location;
        if (!A && C(e, t)) return;
        if (T === S(t)) return;
        T = null, x(t);
      }
    }, x = t => {
      if (A) A = !1, d(); else {
        const e = "POP";
        u.confirmTransitionTo(t, e, o, s => {
          s ? d({
            action: e,
            location: t
          }) : L(t);
        });
      }
    }, L = t => {
      let e = U.lastIndexOf(S(I.location));
      -1 === e && (e = 0);
      let s = U.lastIndexOf(S(t));
      -1 === s && (s = 0);
      const n = e - s;
      n && (A = !0, R(n));
    }, E = X(), B = r(E);
    E !== B && Q(B);
    const W = l();
    let U = [ S(W) ];
    const R = t => {
      warning(s, "Hash history go(n) causes a full page reload in this browser"), e.go(t);
    };
    let D = 0;
    const N = t => {
      1 === (D += t) ? v(window, "hashchange", O) : 0 === D && k(window, "hashchange", O);
    };
    let j = !1;
    const I = {
      length: e.length,
      action: "POP",
      location: W,
      createHref: t => "#" + r(i + S(t)),
      push: (t, e) => {
        warning(void 0 === e, "Hash history cannot push state; it is ignored");
        const s = m(t, void 0, b(n), I.location);
        u.confirmTransitionTo(s, "PUSH", o, t => {
          if (!t) return;
          const e = S(s), n = r(i + e);
          if (X() !== n) {
            T = e, (t => window.location.hash = t)(n);
            const t = U.lastIndexOf(S(I.location)), o = U.slice(0, -1 === t ? 0 : t + 1);
            o.push(e), U = o, d({
              action: "PUSH",
              location: s
            });
          } else warning(!1, "Hash history cannot PUSH the same path; a new entry will not be added to the history stack"), 
          d();
        });
      },
      replace: (t, e) => {
        warning(void 0 === e, "Hash history cannot replace state; it is ignored");
        const s = m(t, void 0, b(n), I.location);
        u.confirmTransitionTo(s, "REPLACE", o, t => {
          if (!t) return;
          const e = S(s), n = r(i + e);
          X() !== n && (T = e, Q(n));
          const o = U.indexOf(S(I.location));
          -1 !== o && (U[o] = e), d({
            action: "REPLACE",
            location: s
          });
        });
      },
      go: R,
      goBack: () => R(-1),
      goForward: () => R(1),
      block: (t = "") => {
        const e = u.setPrompt(t);
        return j || (N(1), j = !0), () => (j && (j = !1, N(-1)), e());
      },
      listen: t => {
        const e = u.appendListener(t);
        return N(1), () => {
          N(-1), e();
        };
      }
    };
    return I;
  }
};

class st {
  constructor() {
    this.root = "/", this.historyType = "browser", this.titleSuffix = "", this.routeViewsUpdated = ((t = {}) => {
      if (t.scrollToId && "browser" === this.historyType) {
        const e = document.getElementById(t.scrollToId);
        if (e) return e.scrollIntoView();
      }
      this.scrollTo(t.scrollTopOffset || this.scrollTopOffset);
    });
  }
  componentWillLoad() {
    this.history = et[this.historyType](), this.history.listen(t => tt(this, void 0, void 0, function*() {
      t = getLocation(t, this.root), this.location = t;
    })), this.location = getLocation(this.history.location, this.root);
  }
  scrollTo(t) {
    if (null != t && !this.isServer && this.history) return "POP" === this.history.action && Array.isArray(this.history.location.scrollPosition) ? this.queue.write(() => {
      this.history && this.history.location && Array.isArray(this.history.location.scrollPosition) && window.scrollTo(this.history.location.scrollPosition[0], this.history.location.scrollPosition[1]);
    }) : this.queue.write(() => {
      window.scrollTo(0, t);
    });
  }
  render() {
    if (this.location && this.history) return t(O.Provider, {
      state: {
        historyType: this.historyType,
        location: this.location,
        titleSuffix: this.titleSuffix,
        root: this.root,
        history: this.history,
        routeViewsUpdated: this.routeViewsUpdated
      }
    }, t("slot", null));
  }
  static get is() {
    return "stencil-router";
  }
  static get properties() {
    return {
      history: {
        state: !0
      },
      historyType: {
        type: String,
        attr: "history-type"
      },
      isServer: {
        context: "isServer"
      },
      location: {
        state: !0
      },
      queue: {
        context: "queue"
      },
      root: {
        type: String,
        attr: "root"
      },
      scrollTopOffset: {
        type: Number,
        attr: "scroll-top-offset"
      },
      titleSuffix: {
        type: String,
        attr: "title-suffix"
      }
    };
  }
}

export { x as AppHome, F as AppRoot, K as WebthreeConnector, _ as StencilRoute, Y as StencilRouteSwitch, st as StencilRouter };